import{P as e,h as n,aa as r}from"./internal-context-eGSwROSk.mjs";import{arbitrumSepolia as t,arbitrum as a,avalancheFuji as i,avalanche as o,baseSepolia as d,base as l,polygonAmoy as s,polygon as c,optimismSepolia as u,optimism as f,sepolia as p,mainnet as E}from"@privy-io/js-sdk-core";import{useCallback as h,useContext as m}from"react";import{cL as g,ak as y,cM as w,ay as C,ac as v,bd as D,b6 as b,ab as T,ad as W}from"./EmbeddedWalletConnectingScreen-DTl397rT.mjs";import{k as S,n as A,W as U,u as x}from"./events-context-DGSLy4O3.mjs";function M(e){return["ethereum","solana"].includes(e.chainType)}function _(e){let n=e.replace("eip155:","");if(n)return parseInt(n);throw Error("Chain ID not compatible with CAIP-2 format.")}const P=e=>e.filter((e=>"wallets"===e.method||("exchange"===e.method?"coinbase"===e.provider:"card"===e.method||"payment-request"===e.method?"coinbase"===e.provider||"moonpay"===e.provider:(e.method,!1)))),F={[E.id]:"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",[p.id]:"0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238",[f.id]:"0x0b2c639c533813f4aa9d7837caf62653d097ff85",[u.id]:"0x5fd84259d66Cd46123540766Be93DFE6D43130D7",[c.id]:"0x3c499c542cef5e3811e1192ce70d8cc03d5c3359",[s.id]:"0x41e94eb019c0762f9bfcf9fb1e58725bfb0e7582",[l.id]:"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",[d.id]:"0x036CbD53842c5426634e7929541eC2318f3dCF7e",[o.id]:"0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",[i.id]:"0x5425890298aed601595a70ab815c96711a31bc65",[a.id]:"0xaf88d065e77c8cC2239327C5EDb3A432268e5831",[t.id]:"0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d"},R=({address:n,appConfig:r,fundWalletConfig:t,methodScreen:a,chainIdOverride:i,comingFromSendTransactionScreen:o=!1})=>{let d,l;if(!r.fundingConfig)throw Error("Wallet funding is not enabled");let s=P(r.fundingConfig.options);if(s.length<1)throw Error("Wallet funding is not enabled");d=i||(t?.chain?t.chain.id:_(r.fundingConfig.defaultRecommendedCurrency.chain));let c=r.chains.find((e=>e.id===d));if(!c)throw new e(`Funding chain ${d} is not in PrivyProvider chains list`);let u=t?.amount??r.fundingConfig.defaultRecommendedAmount,f=!1;function p(){if(!d)return;let e=F[d];s.find((e=>"wallets"===e.method))&&!e&&console.warn("Attempting to fund with USDC on chain where USDC address is not known. Funding via external wallet will be disabled."),l=e,f=!0}var E;t&&"asset"in t?"USDC"===t.asset?p():"string"!=typeof t.asset&&"erc20"in t.asset&&(E=l=t.asset.erc20,f=E===F[c.id]):"USDC"===r.fundingConfig.defaultRecommendedCurrency.asset&&p();let h=t?.defaultFundingMethod;return{chainType:"ethereum",address:n,amount:u,chain:c,erc20Address:l,erc20ContractInfo:f?{symbol:"USDC",decimals:6}:void 0,isUSDC:f,methodScreen:a,supportedOptions:s,comingFromSendTransactionScreen:o,defaultFundingMethod:h,usingDefaultFundingMethod:!!h,preferredCardProvider:t?.card?.preferredProvider,crossChainBridgingEnabled:r.fundingConfig.crossChainBridgingEnabled??!1,solanaChain:"solana:mainnet",uiConfig:t&&"uiConfig"in t?t.uiConfig:void 0,externalSolanaFundingScreen:null}};function I({address:e,fundWalletConfig:n,appConfig:r,comingFromSendTransactionScreen:t,externalSolanaFundingScreen:a,methodScreen:i}){if(!r.fundingConfig)throw Error("Wallet funding is not enabled");let o=P(r.fundingConfig.options);if(o.length<1)throw Error("Wallet funding is not enabled");if("USDC"===n?.asset&&"solana:testnet"===n?.chain)throw Error("USDC funding is not supported on the Solana testnet");let d=n?.amount??r.fundingConfig.defaultRecommendedAmount,l=n?.defaultFundingMethod;return{chainType:"solana",address:e,supportedOptions:o,amount:d,isUSDC:"USDC"===n?.asset,methodScreen:i,comingFromSendTransactionScreen:t,chain:n?.chain||"solana:mainnet",crossChainBridgingEnabled:r.fundingConfig.crossChainBridgingEnabled??!1,defaultFundingMethod:l,preferredCardProvider:n?.card?.preferredProvider,usingDefaultFundingMethod:!!l,uiConfig:n?.uiConfig,externalSolanaFundingScreen:a}}const B=e=>e.reduce(((e,n)=>!e||e.walletIndex<n.walletIndex?n:e),null),O=async({appConfig:e,getAccessToken:r,initializeWalletProxy:t,user:a,privy:i,emitPrivyEvent:o,recoverEmbeddedWallet:d,setModalData:l,openModal:s,setUser:c,options:u,timeoutDuration:f,refreshSessionAndUser:p,chainType:E})=>{let[h,m]=await Promise.all([t(f),r()]);if(!m||!a)throw o("createWallet","onError",n.MUST_BE_AUTHENTICATED),Error("User must be authenticated before creating a Privy wallet");if(!h&&e.customAuth?.enabled)throw o("createWallet","onError",n.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");if(u&&"walletIndex"in u&&"number"==typeof u.walletIndex){if("user-controlled-server-wallets-only"===e.embeddedWallets.mode)throw o("createWallet","onError",n.INVALID_DATA),Error("Invalid input, use `createAdditional` instead of `walletIndex` to create additional wallets.");return k({accessToken:m,appConfig:e,privy:i,emitPrivyEvent:o,openModal:s,proxy:h,refreshSessionAndUser:p,recoverEmbeddedWallet:d,setModalData:l,user:a,walletIndex:u.walletIndex,chainType:E,setUser:c})}let y=u&&"createAdditional"in u&&u.createAdditional,w=g(a,{chainType:E});if(w[0]&&!y)throw o("createWallet","onError",n.EMBEDDED_WALLET_ALREADY_EXISTS),Error("User already has an embedded wallet.");return k({accessToken:m,appConfig:e,privy:i,emitPrivyEvent:o,openModal:s,proxy:h,recoverEmbeddedWallet:d,setModalData:l,user:a,walletIndex:(B(w)?.walletIndex??-1)+1,chainType:E,refreshSessionAndUser:p,setUser:c})};let k=async({accessToken:e,appConfig:r,privy:t,emitPrivyEvent:a,proxy:i,refreshSessionAndUser:o,recoverEmbeddedWallet:d,user:l,walletIndex:s,setModalData:c,openModal:u,chainType:f,setUser:p})=>{if(s<0)throw a("createWallet","onError",n.EMBEDDED_WALLET_CREATE_ERROR),Error(`A negative walletIndex (${s}) is invalid.`);let E=y(l);if(s>0&&!E)throw a("createWallet","onError",n.EMBEDDED_WALLET_NOT_FOUND),Error("Must have an existing embedded wallet to create an additional wallet.");if(r.embeddedWallets.requireUserOwnedRecoveryOnCreate&&"user-controlled-server-wallets-only"===r.embeddedWallets.mode)throw a("createWallet","onError",n.EMBEDDED_WALLET_CREATE_ERROR),Error("User owned recovery not yet supported for this app.");if(!E&&r.embeddedWallets.requireUserOwnedRecoveryOnCreate)return await L({emitPrivyEvent:a,setModalData:c,openModal:u,chainType:f});let h=g(l,{chainType:f,walletIndex:s})[0];if(h)return{user:l,account:h};if(0===s&&!i)return L({emitPrivyEvent:a,setModalData:c,openModal:u,chainType:f});if(!i)throw a("createWallet","onError",n.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");return w({appConfig:r,walletIndex:s,chainType:f,user:l,accessToken:e,proxy:i,refreshSessionAndUser:o,privy:t,recoverEmbeddedWallet:d,setUser:p})},L=async({emitPrivyEvent:e,setModalData:r,openModal:t,chainType:a})=>new Promise(((i,o)=>{r({createWallet:{onSuccess:({user:n,account:r})=>{e("createWallet","onSuccess",{wallet:r}),i({user:n,account:r})},onFailure:r=>{e("createWallet","onError",n.UNKNOWN_EMBEDDED_WALLET_ERROR),o(r)},callAuthOnSuccessOnClose:!1,shouldCreateEth:"ethereum"===a,shouldCreateSol:"solana"===a}}),t(C)}));const N=()=>{let e=S(),t=A(),{setModalData:a}=v(),{initializeWalletProxy:i,recoverEmbeddedWallet:o,setUser:d,openModal:l,refreshSessionAndUser:s,privy:c,client:u}=r();return{create:async({chainType:r,options:f,latestUser:p})=>{let E=p;if(E||(E=await s()),!E)throw t("createWallet","onError",n.MUST_BE_AUTHENTICATED),Error("User must be authenticated before creating a Privy wallet");return await O({appConfig:e,privy:c,getAccessToken:()=>u.getAccessToken(),refreshSessionAndUser:s,initializeWalletProxy:i,user:E,emitPrivyEvent:t,recoverEmbeddedWallet:o,setModalData:a,openModal:l,setUser:d,options:f,timeoutDuration:U,chainType:r})}}};function K(e){let{create:n}=N();return x("createWallet",e),{createWallet:async e=>{e&&"target"in e&&e&&(e=void 0);let{account:r}=await n({chainType:"ethereum",options:e});return r}}}const z=async({emitPrivyEvent:r,getAccessToken:t,initializeWalletProxy:a,refreshSessionAndUser:i,user:o,appConfig:d},{privateKey:l,chainType:s,additionalSigners:c})=>{if(!o)throw r("linkAccount","onError",n.MUST_BE_AUTHENTICATED,{linkMethod:"siwe"}),new e("User must be authenticated before linking an account.");let u="user-controlled-server-wallets-only"===d.embeddedWallets.mode?"tee":"on-device";if(c&&"on-device"===u)throw new e("Specifying additionalSigners is only supported for TEE execution and this app uses On-device execution. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide");let[f,p]=await Promise.all([t(),a(15e3)]);if(!p||!f)throw r("linkAccount","onError",n.MUST_BE_AUTHENTICATED,{linkMethod:"siwe"}),new e("User must be authenticated before linking an account.");let{address:E}=await p.importWallet({privateKey:l,accessToken:f,chainType:s,mode:u,additionalSigners:c}),h=await i(),m="solana"===s?D(h):b(h),g=m?.find((e=>e.address===E));if(!g)throw r("createWallet","onError",n.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to import wallet");return r("createWallet","onSuccess",{wallet:g}),g},j=()=>{let{user:e}=T(),{client:n,refreshSessionAndUser:t,initializeWalletProxy:a}=r(),i=A(),o=S();return{importWallet:h((({privateKey:r,additionalSigners:d})=>z({getAccessToken:()=>n.getAccessToken(),user:e,initializeWalletProxy:a,refreshSessionAndUser:t,emitPrivyEvent:i,appConfig:o},{privateKey:r,chainType:"ethereum",additionalSigners:d})),[e,n,t,a,i,o])}},H=()=>{let{importWallet:e}=j(),{createWallet:n}=K();return{...m(W),importWallet:e,createWallet:n}};export{N as a,K as b,j as c,z as d,_ as e,P as f,I as g,M as i,R as p,H as u};
