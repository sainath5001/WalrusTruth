import{useRef as e,useState as t,useCallback as r}from"react";import{http as n,createPublicClient as a}from"viem";import{ac as i,ab as s,b4 as o,q as l,bL as c,$ as d,H as m,bv as u,bD as p}from"./EmbeddedWalletConnectingScreen-DTl397rT.mjs";import{k as y}from"./events-context-DGSLy4O3.mjs";import{aa as g,P as f}from"./internal-context-eGSwROSk.mjs";import{S as h}from"./SignRequestScreen-Ca9hEGyq.mjs";import{a as w}from"./getEmbeddedConnectedWallet-CM6cDQCS.mjs";import{createSmartAccountClient as P}from"permissionless";import{toThirdwebSmartAccount as I,toLightSmartAccount as W,toBiconomySmartAccount as v,toKernelSmartAccount as F,toSafeSmartAccount as x}from"permissionless/accounts";import{createPimlicoClient as G}from"permissionless/clients/pimlico";import{entryPoint07Address as C,entryPoint06Address as T,toCoinbaseSmartAccount as b}from"viem/account-abstraction";import{THIRDWEB as S,COINBASE_SMART_WALLET as U,LIGHT_ACCOUNT as M,BICONOMY as O,KERNEL as V,SAFE as A}from"@privy-io/js-sdk-core";let D={address:T,version:"0.6"},N={address:C,version:"0.7"},_=({owner:e,smartWalletType:t,smartWalletVersion:r,publicClient:n})=>{switch(t){case A:return x({client:n,entryPoint:N,owners:[e],version:"1.4.1"});case V:return F({client:n,version:"0.3.1",entryPoint:N,useMetaFactory:"optional",owners:[e]});case O:return v({client:n,owners:[e],entryPoint:D});case M:return W({client:n,entryPoint:D,owner:e,version:"1.1.0"});case U:return async function({client:e,owner:t,version:r}){let[n]=await t.request({method:"eth_accounts"});if(!n)throw Error("Unable to request embedded owner for eth_accounts");return await b({client:e,owners:[{type:"local",source:"privy",address:n,sign:async({hash:e})=>await t.request({method:"secp256k1_sign",params:[e]})}],version:r})}({client:n,owner:e,version:r??"1"});case S:return I({client:n,entryPoint:N,owner:e});default:throw Error(`Invalid smart account type: ${t}.`)}};const $=({calls:e,chain:t,maxPriorityFeePerGas:r,maxFeePerGas:n,nonce:a})=>e.map((e=>({to:e.to||void 0,data:e.data,value:e.value,chainId:t.id,nonce:a,maxFeePerGas:n,maxPriorityFeePerGas:r}))),q=async({chain:e,paymasterContext:t,account:r,signer:i,user:s,smartWalletsConfig:o,rpcConfig:l,privyAppId:d})=>{if(!(o?.enabled&&s&&r&&i))return;let m=o?.configuredNetworks.find((t=>t.chainId===`eip155:${e.id}`));if(!m)throw new f(`The chain ${e.name} (eip155:${e.id}) must be configured in the smart wallet configuration in your dashboard`);let u=s.smartWallet?s.smartWallet.smartWalletType:o.smartWalletType,p=s.smartWallet?s.smartWallet.smartWalletVersion:o.smartWalletVersion,y=c(e,l,d),g=a({chain:e,transport:n(y)}),h=t??m.paymasterContext,w=await(async({owner:e,smartWalletType:t,smartWalletVersion:r,chain:a,publicClient:i,bundlerUrl:s,paymasterUrl:o,paymasterContext:l})=>{let c=await _({owner:e,smartWalletType:t,publicClient:i,smartWalletVersion:r}),d=G({transport:n(s),entryPoint:c.entryPoint}),m=o?G({transport:n(o),entryPoint:c.entryPoint}):void 0;return P({account:c,chain:a,paymaster:m,paymasterContext:l,bundlerTransport:n(s),userOperation:{estimateFeesPerGas:async()=>{if(["public.pimlico.io","api.pimlico.io"].some((e=>s.includes(e))))return await d.getUserOperationGasPrice().then((e=>e.fast));if(["rpc.zerodev.app"].some((e=>s.includes(e))))return(await d.request({method:"zd_getUserOperationGasPrice",params:[]})).fast;if(["g.alchemy.com"].some((e=>s.includes(e)))){let[e,t]=await Promise.all([i.getBlock({blockTag:"latest"}),d.request({method:"rundler_maxPriorityFeePerGas",params:[]})]);if(!e.baseFeePerGas||!t)throw Error("Failed to get block or maxPriorityFeePerGasEstimate");return{maxFeePerGas:150n*e.baseFeePerGas/100n+BigInt(t.toString()),maxPriorityFeePerGas:BigInt(t.toString())}}{let e=await i.estimateFeesPerGas(),t=s.includes("api.developer.coinbase.com")?175n:150n;return{...e,maxFeePerGas:e.maxFeePerGas*t/100n,maxPriorityFeePerGas:e.maxPriorityFeePerGas*t/100n}}}}})})({owner:i,smartWalletType:u,smartWalletVersion:p,chain:e,publicClient:g,paymasterContext:h,...m});if(!w)throw new f(`Failed to create smart wallet client for chain ${e.name} (eip155:${e.id})`);return w},B=({clientConfig:n,smartWalletsConfig:a})=>{let{hideWalletUIs:c,openPrivyModal:P,appId:I,isHeadlessSigning:W}=g(),v=y(),{setModalData:F}=i(),{user:x}=s(),{chains:G}=y(),{chainId:C,clients:T,setChainId:b,chainIdState:S}=(()=>{let r=e(),[n,a]=t();return{clients:e({}),setChainId:e=>{r.current=e,a(e)},chainId:r,chainIdState:n}})(),U=G.find((e=>e.id===S)),{wallets:M}=d(),O=o(x),V=w(M,O?.address),A=!!O&&l(O),D=r((async()=>C.current),[C]),N=r((async({id:e})=>{if(!T.current[e]){let t=await q({chain:G.find((t=>t.id===e)),account:O,signer:await(V?.getEthereumProvider()),user:x,paymasterContext:n?.paymasterContext,smartWalletsConfig:a,rpcConfig:v.rpcConfig,privyAppId:I});t&&(T.current[e]=t)}b(e)}),[G,n,M,x,a]);return{wrapSmartAccountClient:e=>{T.current[e.chain.id]=e,S||b(e.chain.id);return{...e,sendTransaction:async(e,t)=>{let r=T.current[C.current];if(!r)throw new f(`Smart wallet client for chain (eip155:${C.current}) not found`);if(delete e.account,W({showWalletUIs:t?.uiOptions?.showWalletUIs}))return c.current=!0,await r.sendTransaction(e).finally((()=>c.current=!1));let n=[];"calls"in e&&void 0!==e.calls?n=[...e.calls]:"to"in e&&(n=[{to:e.to,value:e.value||BigInt(0),data:e.data||"0x"}]);let a=async()=>{let{paymasterAndData:t,paymasterData:a,maxFeePerGas:i,maxPriorityFeePerGas:s}=await r.prepareUserOperation({calls:n,maxFeePerGas:e.maxFeePerGas,maxPriorityFeePerGas:e.maxPriorityFeePerGas,nonce:e.nonce?BigInt(e.nonce):void 0});return 0===Number(i)&&0===Number(s)||Number(t??a??0)>0};return new Promise((async(i,s)=>{c.current=!0;let{entropyId:o,entropyIdVerifier:l}=m(x);F({connectWallet:{recoveryMethod:O.recoveryMethod,connectingWalletAddress:O.address,isUnifiedWallet:A,entropyId:o,entropyIdVerifier:l,onCompleteNavigateTo:p,onFailure:()=>{}},sendTransaction:{transactionRequests:$({calls:n,chain:r.chain,maxPriorityFeePerGas:e.maxPriorityFeePerGas,maxFeePerGas:e.maxFeePerGas,nonce:e.nonce?BigInt(e.nonce):void 0}),transactingWalletIndex:0,transactingWalletAddress:r.account.address,entropyId:o,entropyIdVerifier:l,getIsSponsored:a,signOnly:!1,onConfirm:()=>r.sendTransaction(e),onSuccess:e=>i(e.hash),onFailure:s,uiOptions:t?.uiOptions??{}}}),P(u)})).finally((()=>{c.current=!1}))},signMessage:async(e,t)=>{let r=T.current[C.current];if(!r)throw new f(`Smart wallet client for chain (eip155:${C.current}) not found`);return W({showWalletUIs:t?.uiOptions?.showWalletUIs})?(c.current=!0,await r.signMessage(e).finally((()=>c.current=!1))):new Promise((async(n,a)=>{let{entropyId:i,entropyIdVerifier:s}=m(x);c.current=!0,F({connectWallet:{recoveryMethod:O.recoveryMethod,connectingWalletAddress:O.address,isUnifiedWallet:A,entropyId:i,entropyIdVerifier:s,onCompleteNavigateTo:h,onFailure:()=>{}},signMessage:{method:"personal_sign",data:"string"==typeof e.message?e.message:e.message.raw.toString(),confirmAndSign:()=>r.signMessage(e),onSuccess:e=>n(e),onFailure:a,uiOptions:t?.uiOptions??{}}}),P(u)})).finally((()=>{c.current=!1}))},signTypedData:async(e,t)=>{let r=T.current[C.current];if(!r)throw new f(`Smart wallet client for chain (eip155:${C.current}) not found`);return delete e.account,W({showWalletUIs:t?.uiOptions?.showWalletUIs})?(c.current=!0,await r.signTypedData(e).finally((()=>c.current=!1))):new Promise((async(n,a)=>{c.current=!0;let{entropyId:i,entropyIdVerifier:s}=m(x);F({connectWallet:{recoveryMethod:O.recoveryMethod,connectingWalletAddress:O.address,isUnifiedWallet:A,entropyId:i,entropyIdVerifier:s,onCompleteNavigateTo:h,onFailure:()=>{}},signMessage:{method:"eth_signTypedData_v4",data:e,confirmAndSign:()=>r.signTypedData(e),onSuccess:e=>n(e),onFailure:a,uiOptions:t?.uiOptions??{}}}),P(u)})).finally((()=>{c.current=!1}))},getChainId:D,chain:U,switchChain:N}}}},k=()=>{let{hideWalletUIs:e,openPrivyModal:t,isHeadlessSigning:r}=g(),{setModalData:n}=i(),{user:a}=s(),c=o(a),d=!!c&&l(c);return{wrapSmartAccountClientWithUIs:i=>({...i,sendTransaction:async(s,o)=>{if(r({showWalletUIs:o?.uiOptions?.showWalletUIs}))return e.current=!0,await i.sendTransaction(s).finally((()=>e.current=!1));let l=[];"calls"in s&&void 0!==s.calls?l=[...s.calls]:"to"in s&&(l=[{to:s.to,value:s.value||BigInt(0),data:s.data||"0x"}]);let y=async()=>{if(!i.paymaster)return!1;let{paymasterData:e,paymasterAndData:t}=await i.prepareUserOperation({calls:l,maxFeePerGas:s.maxFeePerGas,maxPriorityFeePerGas:s.maxPriorityFeePerGas,nonce:s.nonce?BigInt(s.nonce):void 0});return Number(t??e??0)>0};return new Promise((async(r,g)=>{e.current=!0;let{entropyId:f,entropyIdVerifier:h}=m(a);n({connectWallet:{recoveryMethod:c.recoveryMethod,connectingWalletAddress:c.address,isUnifiedWallet:d,entropyId:f,entropyIdVerifier:h,onCompleteNavigateTo:p,onFailure:()=>{}},sendTransaction:{transactionRequests:$({calls:l,chain:i.chain,maxPriorityFeePerGas:s.maxPriorityFeePerGas,maxFeePerGas:s.maxFeePerGas,nonce:s.nonce?BigInt(s.nonce):void 0}),transactingWalletIndex:0,transactingWalletAddress:i.account.address,entropyId:f,entropyIdVerifier:h,getIsSponsored:y,signOnly:!1,onConfirm:()=>i.sendTransaction(s),onSuccess:e=>r(e.hash),onFailure:g,uiOptions:o?.uiOptions??{}}}),t(u)})).finally((()=>{e.current=!1}))},signMessage:async(s,o)=>r({showWalletUIs:o?.uiOptions?.showWalletUIs})?(e.current=!0,await i.signMessage(s).finally((()=>e.current=!1))):new Promise((async(r,l)=>{let{entropyId:p,entropyIdVerifier:y}=m(a);e.current=!0,n({connectWallet:{recoveryMethod:c.recoveryMethod,connectingWalletAddress:c.address,isUnifiedWallet:d,entropyId:p,entropyIdVerifier:y,onCompleteNavigateTo:h,onFailure:()=>{}},signMessage:{method:"personal_sign",data:"string"==typeof s.message?s.message:s.message.raw.toString(),confirmAndSign:()=>i.signMessage(s),onSuccess:e=>r(e),onFailure:l,uiOptions:o?.uiOptions??{}}}),t(u)})).finally((()=>{e.current=!1})),signTypedData:async(s,o)=>r({showWalletUIs:o?.uiOptions?.showWalletUIs})?(e.current=!0,await i.signTypedData(s).finally((()=>e.current=!1))):new Promise((async(r,l)=>{e.current=!0;let{entropyId:p,entropyIdVerifier:y}=m(a);n({connectWallet:{recoveryMethod:c.recoveryMethod,connectingWalletAddress:c.address,isUnifiedWallet:d,entropyId:p,entropyIdVerifier:y,onCompleteNavigateTo:h,onFailure:()=>{}},signMessage:{method:"eth_signTypedData_v4",data:s,confirmAndSign:()=>i.signTypedData(s),onSuccess:e=>r(e),onFailure:l,uiOptions:o?.uiOptions??{}}}),t(u)})).finally((()=>{e.current=!1}))})}};export{B as a,$ as c,q as g,k as u};
