"use strict";var e=require("./internal-context-CeWKmK5u.js"),r=require("@privy-io/js-sdk-core"),t=require("react"),n=require("./EmbeddedWalletConnectingScreen-DmH8RMAY.js"),a=require("./events-context-CJ1M8bnZ.js");function i(e){let r=e.replace("eip155:","");if(r)return parseInt(r);throw Error("Chain ID not compatible with CAIP-2 format.")}const o=e=>e.filter((e=>"wallets"===e.method||("exchange"===e.method?"coinbase"===e.provider:"card"===e.method||"payment-request"===e.method?"coinbase"===e.provider||"moonpay"===e.provider:(e.method,!1)))),l={[r.mainnet.id]:"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",[r.sepolia.id]:"0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238",[r.optimism.id]:"0x0b2c639c533813f4aa9d7837caf62653d097ff85",[r.optimismSepolia.id]:"0x5fd84259d66Cd46123540766Be93DFE6D43130D7",[r.polygon.id]:"0x3c499c542cef5e3811e1192ce70d8cc03d5c3359",[r.polygonAmoy.id]:"0x41e94eb019c0762f9bfcf9fb1e58725bfb0e7582",[r.base.id]:"0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",[r.baseSepolia.id]:"0x036CbD53842c5426634e7929541eC2318f3dCF7e",[r.avalanche.id]:"0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",[r.avalancheFuji.id]:"0x5425890298aed601595a70ab815c96711a31bc65",[r.arbitrum.id]:"0xaf88d065e77c8cC2239327C5EDb3A432268e5831",[r.arbitrumSepolia.id]:"0x75faf114eafb1BDbe2F0316DF893fd58CE46AA4d"};const d=e=>e.reduce(((e,r)=>!e||e.walletIndex<r.walletIndex?r:e),null),s=async({appConfig:r,getAccessToken:t,initializeWalletProxy:a,user:i,privy:o,emitPrivyEvent:l,recoverEmbeddedWallet:s,setModalData:u,openModal:p,setUser:E,options:f,timeoutDuration:h,refreshSessionAndUser:y,chainType:m})=>{let[v,g]=await Promise.all([a(h),t()]);if(!g||!i)throw l("createWallet","onError",e.PrivyErrorCode.MUST_BE_AUTHENTICATED),Error("User must be authenticated before creating a Privy wallet");if(!v&&r.customAuth?.enabled)throw l("createWallet","onError",e.PrivyErrorCode.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");if(f&&"walletIndex"in f&&"number"==typeof f.walletIndex){if("user-controlled-server-wallets-only"===r.embeddedWallets.mode)throw l("createWallet","onError",e.PrivyErrorCode.INVALID_DATA),Error("Invalid input, use `createAdditional` instead of `walletIndex` to create additional wallets.");return c({accessToken:g,appConfig:r,privy:o,emitPrivyEvent:l,openModal:p,proxy:v,refreshSessionAndUser:y,recoverEmbeddedWallet:s,setModalData:u,user:i,walletIndex:f.walletIndex,chainType:m,setUser:E})}let C=f&&"createAdditional"in f&&f.createAdditional,w=n.getPrivyWalletsWithFilter(i,{chainType:m});if(w[0]&&!C)throw l("createWallet","onError",e.PrivyErrorCode.EMBEDDED_WALLET_ALREADY_EXISTS),Error("User already has an embedded wallet.");return c({accessToken:g,appConfig:r,privy:o,emitPrivyEvent:l,openModal:p,proxy:v,recoverEmbeddedWallet:s,setModalData:u,user:i,walletIndex:(d(w)?.walletIndex??-1)+1,chainType:m,refreshSessionAndUser:y,setUser:E})};let c=async({accessToken:r,appConfig:t,privy:a,emitPrivyEvent:i,proxy:o,refreshSessionAndUser:l,recoverEmbeddedWallet:d,user:s,walletIndex:c,setModalData:p,openModal:E,chainType:f,setUser:h})=>{if(c<0)throw i("createWallet","onError",e.PrivyErrorCode.EMBEDDED_WALLET_CREATE_ERROR),Error(`A negative walletIndex (${c}) is invalid.`);let y=n.getPrivyPrimaryWallet(s);if(c>0&&!y)throw i("createWallet","onError",e.PrivyErrorCode.EMBEDDED_WALLET_NOT_FOUND),Error("Must have an existing embedded wallet to create an additional wallet.");if(t.embeddedWallets.requireUserOwnedRecoveryOnCreate&&"user-controlled-server-wallets-only"===t.embeddedWallets.mode)throw i("createWallet","onError",e.PrivyErrorCode.EMBEDDED_WALLET_CREATE_ERROR),Error("User owned recovery not yet supported for this app.");if(!y&&t.embeddedWallets.requireUserOwnedRecoveryOnCreate)return await u({emitPrivyEvent:i,setModalData:p,openModal:E,chainType:f});let m=n.getPrivyWalletsWithFilter(s,{chainType:f,walletIndex:c})[0];if(m)return{user:s,account:m};if(0===c&&!o)return u({emitPrivyEvent:i,setModalData:p,openModal:E,chainType:f});if(!o)throw i("createWallet","onError",e.PrivyErrorCode.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to connect to wallet proxy");return n.createWalletAtIndex({appConfig:t,walletIndex:c,chainType:f,user:s,accessToken:r,proxy:o,refreshSessionAndUser:l,privy:a,recoverEmbeddedWallet:d,setUser:h})},u=async({emitPrivyEvent:r,setModalData:t,openModal:a,chainType:i})=>new Promise(((o,l)=>{t({createWallet:{onSuccess:({user:e,account:t})=>{r("createWallet","onSuccess",{wallet:t}),o({user:e,account:t})},onFailure:t=>{r("createWallet","onError",e.PrivyErrorCode.UNKNOWN_EMBEDDED_WALLET_ERROR),l(t)},callAuthOnSuccessOnClose:!1,shouldCreateEth:"ethereum"===i,shouldCreateSol:"solana"===i}}),a(n.EmbeddedWalletOnAccountCreateScreen)}));const p=()=>{let r=a.useAppConfig(),t=a.useEmitPrivyEvent(),{setModalData:i}=n.usePrivyModal(),{initializeWalletProxy:o,recoverEmbeddedWallet:l,setUser:d,openModal:c,refreshSessionAndUser:u,privy:p,client:E}=e.usePrivyInternal();return{create:async({chainType:n,options:f,latestUser:h})=>{let y=h;if(y||(y=await u()),!y)throw t("createWallet","onError",e.PrivyErrorCode.MUST_BE_AUTHENTICATED),Error("User must be authenticated before creating a Privy wallet");return await s({appConfig:r,privy:p,getAccessToken:()=>E.getAccessToken(),refreshSessionAndUser:u,initializeWalletProxy:o,user:y,emitPrivyEvent:t,recoverEmbeddedWallet:l,setModalData:i,openModal:c,setUser:d,options:f,timeoutDuration:a.WALLET_PROXY_TIMEOUT,chainType:n})}}};function E(e){let{create:r}=p();return a.usePrivyEventSubscription("createWallet",e),{createWallet:async e=>{e&&"target"in e&&e&&(e=void 0);let{account:t}=await r({chainType:"ethereum",options:e});return t}}}const f=async({emitPrivyEvent:r,getAccessToken:t,initializeWalletProxy:a,refreshSessionAndUser:i,user:o,appConfig:l},{privateKey:d,chainType:s,additionalSigners:c})=>{if(!o)throw r("linkAccount","onError",e.PrivyErrorCode.MUST_BE_AUTHENTICATED,{linkMethod:"siwe"}),new e.PrivyClientError("User must be authenticated before linking an account.");let u="user-controlled-server-wallets-only"===l.embeddedWallets.mode?"tee":"on-device";if(c&&"on-device"===u)throw new e.PrivyClientError("Specifying additionalSigners is only supported for TEE execution and this app uses On-device execution. Learn more https://docs.privy.io/recipes/tee-wallet-migration-guide");let[p,E]=await Promise.all([t(),a(15e3)]);if(!E||!p)throw r("linkAccount","onError",e.PrivyErrorCode.MUST_BE_AUTHENTICATED,{linkMethod:"siwe"}),new e.PrivyClientError("User must be authenticated before linking an account.");let{address:f}=await E.importWallet({privateKey:d,accessToken:p,chainType:s,mode:u,additionalSigners:c}),h=await i(),y="solana"===s?n.getImportedPrivySolanaWallets(h):n.getImportedPrivyEthereumWallets(h),m=y?.find((e=>e.address===f));if(!m)throw r("createWallet","onError",e.PrivyErrorCode.UNKNOWN_EMBEDDED_WALLET_ERROR),Error("Failed to import wallet");return r("createWallet","onSuccess",{wallet:m}),m},h=()=>{let{user:r}=n.usePrivyContext(),{client:i,refreshSessionAndUser:o,initializeWalletProxy:l}=e.usePrivyInternal(),d=a.useEmitPrivyEvent(),s=a.useAppConfig();return{importWallet:t.useCallback((({privateKey:e,additionalSigners:t})=>f({getAccessToken:()=>i.getAccessToken(),user:r,initializeWalletProxy:l,refreshSessionAndUser:o,emitPrivyEvent:d,appConfig:s},{privateKey:e,chainType:"ethereum",additionalSigners:t})),[r,i,o,l,d,s])}};exports.extractChainIdFromCAIP2=i,exports.filterSupportedOptions=o,exports.importWallet=f,exports.isFirstClassChainWallet=function(e){return["ethereum","solana"].includes(e.chainType)},exports.prepareFundingModalData=({address:r,appConfig:t,fundWalletConfig:n,methodScreen:a,chainIdOverride:d,comingFromSendTransactionScreen:s=!1})=>{let c,u;if(!t.fundingConfig)throw Error("Wallet funding is not enabled");let p=o(t.fundingConfig.options);if(p.length<1)throw Error("Wallet funding is not enabled");c=d||(n?.chain?n.chain.id:i(t.fundingConfig.defaultRecommendedCurrency.chain));let E=t.chains.find((e=>e.id===c));if(!E)throw new e.PrivyClientError(`Funding chain ${c} is not in PrivyProvider chains list`);let f=n?.amount??t.fundingConfig.defaultRecommendedAmount,h=!1;function y(){if(!c)return;let e=l[c];p.find((e=>"wallets"===e.method))&&!e&&console.warn("Attempting to fund with USDC on chain where USDC address is not known. Funding via external wallet will be disabled."),u=e,h=!0}n&&"asset"in n?"USDC"===n.asset?y():"string"!=typeof n.asset&&"erc20"in n.asset&&(h=((e,r)=>e===l[r.id])(u=n.asset.erc20,E)):"USDC"===t.fundingConfig.defaultRecommendedCurrency.asset&&y();let m=n?.defaultFundingMethod;return{chainType:"ethereum",address:r,amount:f,chain:E,erc20Address:u,erc20ContractInfo:h?{symbol:"USDC",decimals:6}:void 0,isUSDC:h,methodScreen:a,supportedOptions:p,comingFromSendTransactionScreen:s,defaultFundingMethod:m,usingDefaultFundingMethod:!!m,preferredCardProvider:n?.card?.preferredProvider,crossChainBridgingEnabled:t.fundingConfig.crossChainBridgingEnabled??!1,solanaChain:"solana:mainnet",uiConfig:n&&"uiConfig"in n?n.uiConfig:void 0,externalSolanaFundingScreen:null}},exports.prepareSolanaFundingModalData=function({address:e,fundWalletConfig:r,appConfig:t,comingFromSendTransactionScreen:n,externalSolanaFundingScreen:a,methodScreen:i}){if(!t.fundingConfig)throw Error("Wallet funding is not enabled");let l=o(t.fundingConfig.options);if(l.length<1)throw Error("Wallet funding is not enabled");if("USDC"===r?.asset&&"solana:testnet"===r?.chain)throw Error("USDC funding is not supported on the Solana testnet");let d=r?.amount??t.fundingConfig.defaultRecommendedAmount,s=r?.defaultFundingMethod;return{chainType:"solana",address:e,supportedOptions:l,amount:d,isUSDC:"USDC"===r?.asset,methodScreen:i,comingFromSendTransactionScreen:n,chain:r?.chain||"solana:mainnet",crossChainBridgingEnabled:t.fundingConfig.crossChainBridgingEnabled??!1,defaultFundingMethod:s,preferredCardProvider:r?.card?.preferredProvider,usingDefaultFundingMethod:!!s,uiConfig:r?.uiConfig,externalSolanaFundingScreen:a}},exports.useCreateWallet=E,exports.useCreateWalletInternal=p,exports.useImportWallet=h,exports.usePrivy=()=>{let{importWallet:e}=h(),{createWallet:r}=E();return{...t.useContext(n.PrivyContext),importWallet:e,createWallet:r}};
