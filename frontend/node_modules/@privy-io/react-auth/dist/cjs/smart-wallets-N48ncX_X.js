"use strict";var e=require("react"),t=require("viem"),r=require("./EmbeddedWalletConnectingScreen-DmH8RMAY.js"),n=require("./events-context-CJ1M8bnZ.js"),a=require("./internal-context-CeWKmK5u.js"),i=require("./SignRequestScreen-DELDI80-.js"),s=require("./getEmbeddedConnectedWallet-6TsVZJkD.js"),o=require("permissionless"),l=require("permissionless/accounts"),c=require("permissionless/clients/pimlico"),d=require("viem/account-abstraction"),u=require("@privy-io/js-sdk-core");let p={address:d.entryPoint06Address,version:"0.6"},y={address:d.entryPoint07Address,version:"0.7"},m=({owner:e,smartWalletType:t,smartWalletVersion:r,publicClient:n})=>{switch(t){case u.SAFE:return l.toSafeSmartAccount({client:n,entryPoint:y,owners:[e],version:"1.4.1"});case u.KERNEL:return l.toKernelSmartAccount({client:n,version:"0.3.1",entryPoint:y,useMetaFactory:"optional",owners:[e]});case u.BICONOMY:return l.toBiconomySmartAccount({client:n,owners:[e],entryPoint:p});case u.LIGHT_ACCOUNT:return l.toLightSmartAccount({client:n,entryPoint:p,owner:e,version:"1.1.0"});case u.COINBASE_SMART_WALLET:return async function({client:e,owner:t,version:r}){let[n]=await t.request({method:"eth_accounts"});if(!n)throw Error("Unable to request embedded owner for eth_accounts");return await d.toCoinbaseSmartAccount({client:e,owners:[{type:"local",source:"privy",address:n,sign:async({hash:e})=>await t.request({method:"secp256k1_sign",params:[e]})}],version:r})}({client:n,owner:e,version:r??"1"});case u.THIRDWEB:return l.toThirdwebSmartAccount({client:n,entryPoint:y,owner:e});default:throw Error(`Invalid smart account type: ${t}.`)}};const g=({calls:e,chain:t,maxPriorityFeePerGas:r,maxFeePerGas:n,nonce:a})=>e.map((e=>({to:e.to||void 0,data:e.data,value:e.value,chainId:t.id,nonce:a,maxFeePerGas:n,maxPriorityFeePerGas:r}))),h=async({chain:e,paymasterContext:n,account:i,signer:s,user:l,smartWalletsConfig:d,rpcConfig:u,privyAppId:p})=>{if(!(d?.enabled&&l&&i&&s))return;let y=d?.configuredNetworks.find((t=>t.chainId===`eip155:${e.id}`));if(!y)throw new a.PrivyClientError(`The chain ${e.name} (eip155:${e.id}) must be configured in the smart wallet configuration in your dashboard`);let g=l.smartWallet?l.smartWallet.smartWalletType:d.smartWalletType,h=l.smartWallet?l.smartWallet.smartWalletVersion:d.smartWalletVersion,P=r.getJsonRpcEndpointFromChain(e,u,p),f=t.createPublicClient({chain:e,transport:t.http(P)}),W=n??y.paymasterContext,w=await(async({owner:e,smartWalletType:r,smartWalletVersion:n,chain:a,publicClient:i,bundlerUrl:s,paymasterUrl:l,paymasterContext:d})=>{let u=await m({owner:e,smartWalletType:r,publicClient:i,smartWalletVersion:n}),p=c.createPimlicoClient({transport:t.http(s),entryPoint:u.entryPoint}),y=l?c.createPimlicoClient({transport:t.http(l),entryPoint:u.entryPoint}):void 0;return o.createSmartAccountClient({account:u,chain:a,paymaster:y,paymasterContext:d,bundlerTransport:t.http(s),userOperation:{estimateFeesPerGas:async()=>{if(["public.pimlico.io","api.pimlico.io"].some((e=>s.includes(e))))return await p.getUserOperationGasPrice().then((e=>e.fast));if(["rpc.zerodev.app"].some((e=>s.includes(e))))return(await p.request({method:"zd_getUserOperationGasPrice",params:[]})).fast;if(["g.alchemy.com"].some((e=>s.includes(e)))){let[e,t]=await Promise.all([i.getBlock({blockTag:"latest"}),p.request({method:"rundler_maxPriorityFeePerGas",params:[]})]);if(!e.baseFeePerGas||!t)throw Error("Failed to get block or maxPriorityFeePerGasEstimate");return{maxFeePerGas:150n*e.baseFeePerGas/100n+BigInt(t.toString()),maxPriorityFeePerGas:BigInt(t.toString())}}{let e=await i.estimateFeesPerGas(),t=s.includes("api.developer.coinbase.com")?175n:150n;return{...e,maxFeePerGas:e.maxFeePerGas*t/100n,maxPriorityFeePerGas:e.maxPriorityFeePerGas*t/100n}}}}})})({owner:s,smartWalletType:g,smartWalletVersion:h,chain:e,publicClient:f,paymasterContext:W,...y});if(!w)throw new a.PrivyClientError(`Failed to create smart wallet client for chain ${e.name} (eip155:${e.id})`);return w};exports.callsToTransactionRequests=g,exports.getSmartWalletClient=h,exports.useSmartWalletsUIWrapper=()=>{let{hideWalletUIs:e,openPrivyModal:t,isHeadlessSigning:n}=a.usePrivyInternal(),{setModalData:s}=r.usePrivyModal(),{user:o}=r.usePrivyContext(),l=r.getPrivyEthereumWallet(o),c=!!l&&r.getIsUnifiedWallet(l);return{wrapSmartAccountClientWithUIs:a=>({...a,sendTransaction:async(i,d)=>{if(n({showWalletUIs:d?.uiOptions?.showWalletUIs}))return e.current=!0,await a.sendTransaction(i).finally((()=>e.current=!1));let u=[];"calls"in i&&void 0!==i.calls?u=[...i.calls]:"to"in i&&(u=[{to:i.to,value:i.value||BigInt(0),data:i.data||"0x"}]);let p=async()=>{if(!a.paymaster)return!1;let{paymasterData:e,paymasterAndData:t}=await a.prepareUserOperation({calls:u,maxFeePerGas:i.maxFeePerGas,maxPriorityFeePerGas:i.maxPriorityFeePerGas,nonce:i.nonce?BigInt(i.nonce):void 0});return Number(t??e??0)>0};return new Promise((async(n,y)=>{e.current=!0;let{entropyId:m,entropyIdVerifier:h}=r.getEntropyDetailsForUser(o);s({connectWallet:{recoveryMethod:l.recoveryMethod,connectingWalletAddress:l.address,isUnifiedWallet:c,entropyId:m,entropyIdVerifier:h,onCompleteNavigateTo:r.SendTransactionScreen,onFailure:()=>{}},sendTransaction:{transactionRequests:g({calls:u,chain:a.chain,maxPriorityFeePerGas:i.maxPriorityFeePerGas,maxFeePerGas:i.maxFeePerGas,nonce:i.nonce?BigInt(i.nonce):void 0}),transactingWalletIndex:0,transactingWalletAddress:a.account.address,entropyId:m,entropyIdVerifier:h,getIsSponsored:p,signOnly:!1,onConfirm:()=>a.sendTransaction(i),onSuccess:e=>n(e.hash),onFailure:y,uiOptions:d?.uiOptions??{}}}),t(r.EmbeddedWalletConnectingScreen)})).finally((()=>{e.current=!1}))},signMessage:async(d,u)=>n({showWalletUIs:u?.uiOptions?.showWalletUIs})?(e.current=!0,await a.signMessage(d).finally((()=>e.current=!1))):new Promise((async(n,p)=>{let{entropyId:y,entropyIdVerifier:m}=r.getEntropyDetailsForUser(o);e.current=!0,s({connectWallet:{recoveryMethod:l.recoveryMethod,connectingWalletAddress:l.address,isUnifiedWallet:c,entropyId:y,entropyIdVerifier:m,onCompleteNavigateTo:i.SignRequestScreen,onFailure:()=>{}},signMessage:{method:"personal_sign",data:"string"==typeof d.message?d.message:d.message.raw.toString(),confirmAndSign:()=>a.signMessage(d),onSuccess:e=>n(e),onFailure:p,uiOptions:u?.uiOptions??{}}}),t(r.EmbeddedWalletConnectingScreen)})).finally((()=>{e.current=!1})),signTypedData:async(d,u)=>n({showWalletUIs:u?.uiOptions?.showWalletUIs})?(e.current=!0,await a.signTypedData(d).finally((()=>e.current=!1))):new Promise((async(n,p)=>{e.current=!0;let{entropyId:y,entropyIdVerifier:m}=r.getEntropyDetailsForUser(o);s({connectWallet:{recoveryMethod:l.recoveryMethod,connectingWalletAddress:l.address,isUnifiedWallet:c,entropyId:y,entropyIdVerifier:m,onCompleteNavigateTo:i.SignRequestScreen,onFailure:()=>{}},signMessage:{method:"eth_signTypedData_v4",data:d,confirmAndSign:()=>a.signTypedData(d),onSuccess:e=>n(e),onFailure:p,uiOptions:u?.uiOptions??{}}}),t(r.EmbeddedWalletConnectingScreen)})).finally((()=>{e.current=!1}))})}},exports.useSmartWalletsWrapper=({clientConfig:t,smartWalletsConfig:o})=>{let{hideWalletUIs:l,openPrivyModal:c,appId:d,isHeadlessSigning:u}=a.usePrivyInternal(),p=n.useAppConfig(),{setModalData:y}=r.usePrivyModal(),{user:m}=r.usePrivyContext(),{chains:P}=n.useAppConfig(),{chainId:f,clients:W,setChainId:w,chainIdState:I}=(()=>{let t=e.useRef(),[r,n]=e.useState();return{clients:e.useRef({}),setChainId:e=>{t.current=e,n(e)},chainId:t,chainIdState:r}})(),v=P.find((e=>e.id===I)),{wallets:C}=r.useWallets(),S=r.getPrivyEthereumWallet(m),F=s.getEmbeddedConnectedWalletWithAddress(C,S?.address),x=!!S&&r.getIsUnifiedWallet(S),T=e.useCallback((async()=>f.current),[f]),U=e.useCallback((async({id:e})=>{if(!W.current[e]){let r=await h({chain:P.find((t=>t.id===e)),account:S,signer:await(F?.getEthereumProvider()),user:m,paymasterContext:t?.paymasterContext,smartWalletsConfig:o,rpcConfig:p.rpcConfig,privyAppId:d});r&&(W.current[e]=r)}w(e)}),[P,t,C,m,o]);return{wrapSmartAccountClient:e=>{W.current[e.chain.id]=e,I||w(e.chain.id);return{...e,sendTransaction:async(e,t)=>{let n=W.current[f.current];if(!n)throw new a.PrivyClientError(`Smart wallet client for chain (eip155:${f.current}) not found`);if(delete e.account,u({showWalletUIs:t?.uiOptions?.showWalletUIs}))return l.current=!0,await n.sendTransaction(e).finally((()=>l.current=!1));let i=[];"calls"in e&&void 0!==e.calls?i=[...e.calls]:"to"in e&&(i=[{to:e.to,value:e.value||BigInt(0),data:e.data||"0x"}]);let s=async()=>{let{paymasterAndData:t,paymasterData:r,maxFeePerGas:a,maxPriorityFeePerGas:s}=await n.prepareUserOperation({calls:i,maxFeePerGas:e.maxFeePerGas,maxPriorityFeePerGas:e.maxPriorityFeePerGas,nonce:e.nonce?BigInt(e.nonce):void 0});return 0===Number(a)&&0===Number(s)||Number(t??r??0)>0};return new Promise((async(a,o)=>{l.current=!0;let{entropyId:d,entropyIdVerifier:u}=r.getEntropyDetailsForUser(m);y({connectWallet:{recoveryMethod:S.recoveryMethod,connectingWalletAddress:S.address,isUnifiedWallet:x,entropyId:d,entropyIdVerifier:u,onCompleteNavigateTo:r.SendTransactionScreen,onFailure:()=>{}},sendTransaction:{transactionRequests:g({calls:i,chain:n.chain,maxPriorityFeePerGas:e.maxPriorityFeePerGas,maxFeePerGas:e.maxFeePerGas,nonce:e.nonce?BigInt(e.nonce):void 0}),transactingWalletIndex:0,transactingWalletAddress:n.account.address,entropyId:d,entropyIdVerifier:u,getIsSponsored:s,signOnly:!1,onConfirm:()=>n.sendTransaction(e),onSuccess:e=>a(e.hash),onFailure:o,uiOptions:t?.uiOptions??{}}}),c(r.EmbeddedWalletConnectingScreen)})).finally((()=>{l.current=!1}))},signMessage:async(e,t)=>{let n=W.current[f.current];if(!n)throw new a.PrivyClientError(`Smart wallet client for chain (eip155:${f.current}) not found`);return u({showWalletUIs:t?.uiOptions?.showWalletUIs})?(l.current=!0,await n.signMessage(e).finally((()=>l.current=!1))):new Promise((async(a,s)=>{let{entropyId:o,entropyIdVerifier:d}=r.getEntropyDetailsForUser(m);l.current=!0,y({connectWallet:{recoveryMethod:S.recoveryMethod,connectingWalletAddress:S.address,isUnifiedWallet:x,entropyId:o,entropyIdVerifier:d,onCompleteNavigateTo:i.SignRequestScreen,onFailure:()=>{}},signMessage:{method:"personal_sign",data:"string"==typeof e.message?e.message:e.message.raw.toString(),confirmAndSign:()=>n.signMessage(e),onSuccess:e=>a(e),onFailure:s,uiOptions:t?.uiOptions??{}}}),c(r.EmbeddedWalletConnectingScreen)})).finally((()=>{l.current=!1}))},signTypedData:async(e,t)=>{let n=W.current[f.current];if(!n)throw new a.PrivyClientError(`Smart wallet client for chain (eip155:${f.current}) not found`);return delete e.account,u({showWalletUIs:t?.uiOptions?.showWalletUIs})?(l.current=!0,await n.signTypedData(e).finally((()=>l.current=!1))):new Promise((async(a,s)=>{l.current=!0;let{entropyId:o,entropyIdVerifier:d}=r.getEntropyDetailsForUser(m);y({connectWallet:{recoveryMethod:S.recoveryMethod,connectingWalletAddress:S.address,isUnifiedWallet:x,entropyId:o,entropyIdVerifier:d,onCompleteNavigateTo:i.SignRequestScreen,onFailure:()=>{}},signMessage:{method:"eth_signTypedData_v4",data:e,confirmAndSign:()=>n.signTypedData(e),onSuccess:e=>a(e),onFailure:s,uiOptions:t?.uiOptions??{}}}),c(r.EmbeddedWalletConnectingScreen)})).finally((()=>{l.current=!1}))},getChainId:T,chain:v,switchChain:U}}}};
