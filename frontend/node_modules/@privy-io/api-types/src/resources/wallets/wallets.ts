// File generated from our OpenAPI spec by Stainless. See CONTRIBUTING.md for details.

import { APIResource } from '../../core/resource';
import * as WalletsAPI from './wallets';
import * as BalanceAPI from './balance';
import { Balance, BalanceGetParams, BalanceGetResponse } from './balance';
import * as TransactionsAPI from './transactions';
import { TransactionGetParams, TransactionGetResponse, Transactions } from './transactions';
import { APIPromise } from '../../core/api-promise';
import { Cursor, type CursorParams, PagePromise } from '../../core/pagination';
import { buildHeaders } from '../../internal/headers';
import { RequestOptions } from '../../internal/request-options';
import { path } from '../../internal/utils/path';

export class Wallets extends APIResource {
  transactions: TransactionsAPI.Transactions = new TransactionsAPI.Transactions(this._client);
  balance: BalanceAPI.Balance = new BalanceAPI.Balance(this._client);

  /**
   * Create a new wallet.
   *
   * @example
   * ```ts
   * const wallet = await client.wallets.create({
   *   chain_type: 'ethereum',
   * });
   * ```
   */
  create(params: WalletCreateParams, options?: RequestOptions): APIPromise<Wallet> {
    const { 'privy-idempotency-key': privyIdempotencyKey, ...body } = params;
    return this._client.post('/v1/wallets', {
      body,
      ...options,
      headers: buildHeaders([
        { ...(privyIdempotencyKey != null ? { 'privy-idempotency-key': privyIdempotencyKey } : undefined) },
        options?.headers,
      ]),
    });
  }

  /**
   * Get all wallets in your app.
   *
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const wallet of client.wallets.list()) {
   *   // ...
   * }
   * ```
   */
  list(
    query: WalletListParams | null | undefined = {},
    options?: RequestOptions,
  ): PagePromise<WalletsCursor, Wallet> {
    return this._client.getAPIList('/v1/wallets', Cursor<Wallet>, { query, ...options });
  }

  /**
   * Export a wallet's private key
   *
   * @example
   * ```ts
   * const response = await client.wallets._export('wallet_id', {
   *   encryption_type: 'HPKE',
   *   recipient_public_key:
   *     'BDAZLOIdTaPycEYkgG0MvCzbIKJLli/yWkAV5yCa9yOsZ4JsrLweA5MnP8YIiY4k/RRzC+APhhO+P+Hoz/rt7Go=',
   * });
   * ```
   */
  _export(
    walletID: string,
    params: WalletExportParams,
    options?: RequestOptions,
  ): APIPromise<WalletExportResponse> {
    const { 'privy-authorization-signature': privyAuthorizationSignature, ...body } = params;
    return this._client.post(path`/v1/wallets/${walletID}/export`, {
      body,
      ...options,
      headers: buildHeaders([
        {
          ...(privyAuthorizationSignature != null ?
            { 'privy-authorization-signature': privyAuthorizationSignature }
          : undefined),
        },
        options?.headers,
      ]),
    });
  }

  /**
   * Initialize a wallet import. Complete by submitting the import.
   *
   * @example
   * ```ts
   * const response = await client.wallets._initImport({
   *   address: 'address',
   *   chain_type: 'ethereum',
   *   encryption_type: 'HPKE',
   *   entropy_type: 'hd',
   *   index: 0,
   * });
   * ```
   */
  _initImport(body: WalletInitImportParams, options?: RequestOptions): APIPromise<WalletInitImportResponse> {
    return this._client.post('/v1/wallets/import/init', { body, ...options });
  }

  /**
   * Sign a message with a wallet by wallet ID.
   *
   * @example
   * ```ts
   * const response = await client.wallets._rawSign(
   *   'wallet_id',
   *   { params: {} },
   * );
   * ```
   */
  _rawSign(
    walletID: string,
    params: WalletRawSignParams,
    options?: RequestOptions,
  ): APIPromise<WalletRawSignResponse> {
    const {
      'privy-authorization-signature': privyAuthorizationSignature,
      'privy-idempotency-key': privyIdempotencyKey,
      ...body
    } = params;
    return this._client.post(path`/v1/wallets/${walletID}/raw_sign`, {
      body,
      ...options,
      headers: buildHeaders([
        {
          ...(privyAuthorizationSignature != null ?
            { 'privy-authorization-signature': privyAuthorizationSignature }
          : undefined),
          ...(privyIdempotencyKey != null ? { 'privy-idempotency-key': privyIdempotencyKey } : undefined),
        },
        options?.headers,
      ]),
    });
  }

  /**
   * Sign a message or transaction with a wallet by wallet ID.
   *
   * @example
   * ```ts
   * const response = await client.wallets._rpc('wallet_id', {
   *   method: 'eth_signTransaction',
   *   params: { transaction: {} },
   * });
   * ```
   */
  _rpc(walletID: string, params: WalletRpcParams, options?: RequestOptions): APIPromise<WalletRpcResponse> {
    const {
      'privy-authorization-signature': privyAuthorizationSignature,
      'privy-idempotency-key': privyIdempotencyKey,
      ...body
    } = params;
    return this._client.post(path`/v1/wallets/${walletID}/rpc`, {
      body,
      ...options,
      headers: buildHeaders([
        {
          ...(privyAuthorizationSignature != null ?
            { 'privy-authorization-signature': privyAuthorizationSignature }
          : undefined),
          ...(privyIdempotencyKey != null ? { 'privy-idempotency-key': privyIdempotencyKey } : undefined),
        },
        options?.headers,
      ]),
    });
  }

  /**
   * Submit a wallet import request.
   *
   * @example
   * ```ts
   * const wallet = await client.wallets._submitImport({
   *   wallet: {
   *     address: '0xF1DBff66C993EE895C8cb176c30b07A559d76496',
   *     chain_type: 'ethereum',
   *     ciphertext:
   *       'PRoRXygG+YYSDBXjCopNYZmx8Z6nvdl1D0lpePTYZdZI2VGfK+LkFt+GlEJqdoi9',
   *     encapsulated_key:
   *       'BOhR6xITDt5THJawHHJKrKdI9CBr2M/SDWzZZAaOW4gCMsSpC65U007WyKiwuuOVAo1BNm4YgcBBROuMmyIZXZk=',
   *     encryption_type: 'HPKE',
   *     entropy_type: 'private-key',
   *   },
   * });
   * ```
   */
  _submitImport(body: WalletSubmitImportParams, options?: RequestOptions): APIPromise<Wallet> {
    return this._client.post('/v1/wallets/import/submit', { body, ...options });
  }

  /**
   * Update a wallet's policies or authorization key configuration.
   *
   * @example
   * ```ts
   * const wallet = await client.wallets._update('wallet_id');
   * ```
   */
  _update(walletID: string, params: WalletUpdateParams, options?: RequestOptions): APIPromise<Wallet> {
    const { 'privy-authorization-signature': privyAuthorizationSignature, ...body } = params;
    return this._client.patch(path`/v1/wallets/${walletID}`, {
      body,
      ...options,
      headers: buildHeaders([
        {
          ...(privyAuthorizationSignature != null ?
            { 'privy-authorization-signature': privyAuthorizationSignature }
          : undefined),
        },
        options?.headers,
      ]),
    });
  }

  /**
   * Obtain a session key to enable wallet access.
   *
   * @example
   * ```ts
   * const response = await client.wallets.authenticateWithJwt({
   *   user_jwt:
   *     'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWUsImlhdCI6MTUxNjIzOTAyMn0.KMUFsIDTnFmyG3nMiGM6H9FNFUROf3wh7SmqJp-QV30',
   * });
   * ```
   */
  authenticateWithJwt(
    body: WalletAuthenticateWithJwtParams,
    options?: RequestOptions,
  ): APIPromise<WalletAuthenticateWithJwtResponse> {
    return this._client.post('/v1/wallets/authenticate', { body, ...options });
  }

  /**
   * Create wallets with an associated recovery user.
   *
   * @deprecated
   */
  createWalletsWithRecovery(
    body: WalletCreateWalletsWithRecoveryParams,
    options?: RequestOptions,
  ): APIPromise<WalletCreateWalletsWithRecoveryResponse> {
    return this._client.post('/v1/wallets_with_recovery', { body, ...options });
  }

  /**
   * Get a wallet by wallet ID.
   *
   * @example
   * ```ts
   * const wallet = await client.wallets.get('wallet_id');
   * ```
   */
  get(walletID: string, options?: RequestOptions): APIPromise<Wallet> {
    return this._client.get(path`/v1/wallets/${walletID}`, options);
  }
}

export type WalletsCursor = Cursor<Wallet>;

/**
 * The wallet chain types that support curve-based signing.
 */
export type CurveSigningChainType =
  | 'cosmos'
  | 'stellar'
  | 'sui'
  | 'aptos'
  | 'movement'
  | 'tron'
  | 'bitcoin-segwit'
  | 'near'
  | 'ton'
  | 'starknet';

/**
 * The wallet chain types that offer first class support.
 */
export type FirstClassChainType = 'solana' | 'ethereum';

export interface Wallet {
  /**
   * Unique ID of the wallet. This will be the primary identifier when using the
   * wallet in the future.
   */
  id: string;

  /**
   * Additional signers for the wallet.
   */
  additional_signers: Array<Wallet.AdditionalSigner>;

  /**
   * Address of the wallet.
   */
  address: string;

  /**
   * The wallet chain types.
   */
  chain_type: WalletChainType;

  /**
   * Unix timestamp of when the wallet was created in milliseconds.
   */
  created_at: number;

  /**
   * Unix timestamp of when the wallet was exported in milliseconds, if the wallet
   * was exported.
   */
  exported_at: number | null;

  /**
   * Unix timestamp of when the wallet was imported in milliseconds, if the wallet
   * was imported.
   */
  imported_at: number | null;

  /**
   * The key quorum ID of the owner of the wallet.
   */
  owner_id: string | null;

  /**
   * List of policy IDs for policies that are enforced on the wallet.
   */
  policy_ids: Array<string>;

  /**
   * The compressed, raw public key for the wallet along the chain cryptographic
   * curve.
   */
  public_key?: string;
}

export namespace Wallet {
  export interface AdditionalSigner {
    signer_id: string;

    /**
     * The array of policy IDs that will be applied to wallet requests. If specified,
     * this will override the base policy IDs set on the wallet.
     */
    override_policy_ids?: Array<string>;
  }
}

/**
 * The wallet chain types.
 */
export type WalletChainType =
  | 'solana'
  | 'ethereum'
  | 'cosmos'
  | 'stellar'
  | 'sui'
  | 'aptos'
  | 'movement'
  | 'tron'
  | 'bitcoin-segwit'
  | 'near'
  | 'ton'
  | 'starknet'
  | 'spark';

/**
 * The response body from revoking a wallet delegation.
 */
export interface WalletRevokeResponse {
  message: string;
}

export interface WalletExportResponse {
  /**
   * The encrypted private key.
   */
  ciphertext: string;

  /**
   * The base64-encoded encapsulated key that was generated during encryption, for
   * use during decryption.
   */
  encapsulated_key: string;

  /**
   * The encryption type of the wallet to import. Currently only supports `HPKE`.
   */
  encryption_type: 'HPKE';
}

export interface WalletInitImportResponse {
  /**
   * The base64-encoded encryption public key to encrypt the wallet entropy with.
   */
  encryption_public_key: string;

  /**
   * The encryption type of the wallet to import. Currently only supports `HPKE`.
   */
  encryption_type: 'HPKE';
}

export interface WalletRawSignResponse {
  data: WalletRawSignResponse.Data;
}

export namespace WalletRawSignResponse {
  export interface Data {
    encoding: 'hex';

    signature: string;
  }
}

export type WalletRpcResponse =
  | WalletRpcResponse.SolanaSignTransactionRpcResponse
  | WalletRpcResponse.SolanaSignAndSendTransactionRpcResponse
  | WalletRpcResponse.SolanaSignMessageRpcResponse
  | WalletRpcResponse.EthereumSignTransactionRpcResponse
  | WalletRpcResponse.EthereumSendTransactionRpcResponse
  | WalletRpcResponse.EthereumPersonalSignRpcResponse
  | WalletRpcResponse.EthereumSignTypedDataRpcResponse
  | WalletRpcResponse.EthereumSign7702AuthorizationRpcResponse
  | WalletRpcResponse.EthereumSecp256k1SignRpcResponse;

export namespace WalletRpcResponse {
  export interface SolanaSignTransactionRpcResponse {
    data: SolanaSignTransactionRpcResponse.Data;

    method: 'signTransaction';
  }

  export namespace SolanaSignTransactionRpcResponse {
    export interface Data {
      encoding: 'base64';

      signed_transaction: string;
    }
  }

  export interface SolanaSignAndSendTransactionRpcResponse {
    data: SolanaSignAndSendTransactionRpcResponse.Data;

    method: 'signAndSendTransaction';
  }

  export namespace SolanaSignAndSendTransactionRpcResponse {
    export interface Data {
      caip2: string;

      hash: string;

      transaction_id?: string;
    }
  }

  export interface SolanaSignMessageRpcResponse {
    data: SolanaSignMessageRpcResponse.Data;

    method: 'signMessage';
  }

  export namespace SolanaSignMessageRpcResponse {
    export interface Data {
      encoding: 'base64';

      signature: string;
    }
  }

  export interface EthereumSignTransactionRpcResponse {
    data: EthereumSignTransactionRpcResponse.Data;

    method: 'eth_signTransaction';
  }

  export namespace EthereumSignTransactionRpcResponse {
    export interface Data {
      encoding: 'rlp';

      signed_transaction: string;
    }
  }

  export interface EthereumSendTransactionRpcResponse {
    data: EthereumSendTransactionRpcResponse.Data;

    method: 'eth_sendTransaction';
  }

  export namespace EthereumSendTransactionRpcResponse {
    export interface Data {
      caip2: string;

      hash: string;

      transaction_id?: string;

      transaction_request?: Data.TransactionRequest;
    }

    export namespace Data {
      export interface TransactionRequest {
        chain_id?: string | number;

        data?: string;

        from?: string;

        gas_limit?: string | number;

        gas_price?: string | number;

        max_fee_per_gas?: string | number;

        max_priority_fee_per_gas?: string | number;

        nonce?: string | number;

        to?: string;

        type?: 0 | 1 | 2;

        value?: string | number;
      }
    }
  }

  export interface EthereumPersonalSignRpcResponse {
    data: EthereumPersonalSignRpcResponse.Data;

    method: 'personal_sign';
  }

  export namespace EthereumPersonalSignRpcResponse {
    export interface Data {
      encoding: 'hex';

      signature: string;
    }
  }

  export interface EthereumSignTypedDataRpcResponse {
    data: EthereumSignTypedDataRpcResponse.Data;

    method: 'eth_signTypedData_v4';
  }

  export namespace EthereumSignTypedDataRpcResponse {
    export interface Data {
      encoding: 'hex';

      signature: string;
    }
  }

  export interface EthereumSign7702AuthorizationRpcResponse {
    data: EthereumSign7702AuthorizationRpcResponse.Data;

    method: 'eth_sign7702Authorization';
  }

  export namespace EthereumSign7702AuthorizationRpcResponse {
    export interface Data {
      authorization: Data.Authorization;
    }

    export namespace Data {
      export interface Authorization {
        chain_id: string | number;

        contract: string;

        nonce: string | number;

        r: string;

        s: string;

        y_parity: number;
      }
    }
  }

  export interface EthereumSecp256k1SignRpcResponse {
    data: EthereumSecp256k1SignRpcResponse.Data;

    method: 'secp256k1_sign';
  }

  export namespace EthereumSecp256k1SignRpcResponse {
    export interface Data {
      encoding: 'hex';

      signature: string;
    }
  }
}

export type WalletAuthenticateWithJwtResponse =
  | WalletAuthenticateWithJwtResponse.WithEncryption
  | WalletAuthenticateWithJwtResponse.WithoutEncryption;

export namespace WalletAuthenticateWithJwtResponse {
  export interface WithEncryption {
    /**
     * The encrypted authorization key data.
     */
    encrypted_authorization_key: WithEncryption.EncryptedAuthorizationKey;

    /**
     * The expiration time of the authorization key in seconds since the epoch.
     */
    expires_at: number;

    wallets: Array<WalletsAPI.Wallet>;
  }

  export namespace WithEncryption {
    /**
     * The encrypted authorization key data.
     */
    export interface EncryptedAuthorizationKey {
      /**
       * The encrypted authorization key corresponding to the user's current
       * authentication session.
       */
      ciphertext: string;

      /**
       * Base64-encoded ephemeral public key used in the HPKE encryption process.
       * Required for decryption.
       */
      encapsulated_key: string;

      /**
       * The encryption type used. Currently only supports HPKE.
       */
      encryption_type: 'HPKE';
    }
  }

  export interface WithoutEncryption {
    /**
     * The raw authorization key data.
     */
    authorization_key: string;

    /**
     * The expiration time of the authorization key in seconds since the epoch.
     */
    expires_at: number;

    wallets: Array<WalletsAPI.Wallet>;
  }
}

export interface WalletCreateWalletsWithRecoveryResponse {
  /**
   * The ID of the created user.
   */
  recovery_user_id: string;

  /**
   * The wallets that were created.
   */
  wallets: Array<Wallet>;
}

export interface WalletCreateParams {
  /**
   * Body param: The wallet chain types.
   */
  chain_type: WalletChainType;

  /**
   * Body param: Additional signers for the wallet.
   */
  additional_signers?: Array<WalletCreateParams.AdditionalSigner>;

  /**
   * Body param: The owner of the resource. If you provide this, do not specify an
   * owner_id as it will be generated automatically. When updating a wallet, you can
   * set the owner to null to remove the owner.
   */
  owner?: WalletCreateParams.PublicKeyOwner | WalletCreateParams.UserOwner | null;

  /**
   * Body param: The key quorum ID to set as the owner of the resource. If you
   * provide this, do not specify an owner.
   */
  owner_id?: string;

  /**
   * Body param: List of policy IDs for policies that should be enforced on the
   * wallet. Currently, only one policy is supported per wallet.
   */
  policy_ids?: Array<string>;

  /**
   * Header param: Idempotency keys ensure API requests are executed only once within
   * a 24-hour window.
   */
  'privy-idempotency-key'?: string;
}

export namespace WalletCreateParams {
  export interface AdditionalSigner {
    signer_id: string;

    /**
     * The array of policy IDs that will be applied to wallet requests. If specified,
     * this will override the base policy IDs set on the wallet.
     */
    override_policy_ids?: Array<string>;
  }

  /**
   * The P-256 public key of the owner of the resource. If you provide this, do not
   * specify an owner_id as it will be generated automatically.
   */
  export interface PublicKeyOwner {
    public_key: string;
  }

  /**
   * The user ID of the owner of the resource. The user must already exist, and this
   * value must start with "did:privy:". If you provide this, do not specify an
   * owner_id as it will be generated automatically.
   */
  export interface UserOwner {
    user_id: string;
  }
}

export interface WalletListParams extends CursorParams {
  chain_type?:
    | 'cosmos'
    | 'stellar'
    | 'sui'
    | 'aptos'
    | 'movement'
    | 'tron'
    | 'bitcoin-segwit'
    | 'near'
    | 'ton'
    | 'starknet'
    | 'spark'
    | 'solana'
    | 'ethereum';

  user_id?: string;
}

export interface WalletExportParams {
  /**
   * Body param: The encryption type of the wallet to import. Currently only supports
   * `HPKE`.
   */
  encryption_type: 'HPKE';

  /**
   * Body param: The base64-encoded encryption public key to encrypt the wallet
   * private key with.
   */
  recipient_public_key: string;

  /**
   * Header param: Request authorization signature. If multiple signatures are
   * required, they should be comma separated.
   */
  'privy-authorization-signature'?: string;
}

export type WalletInitImportParams =
  | WalletInitImportParams.HDInitInput
  | WalletInitImportParams.PrivateKeyInitInput;

export declare namespace WalletInitImportParams {
  export interface HDInitInput {
    /**
     * The address of the wallet to import.
     */
    address: string;

    /**
     * The chain type of the wallet to import. Currently supports `ethereum` and
     * `solana`.
     */
    chain_type: 'ethereum' | 'solana';

    /**
     * The encryption type of the wallet to import. Currently only supports `HPKE`.
     */
    encryption_type: 'HPKE';

    /**
     * The entropy type of the wallet to import.
     */
    entropy_type: 'hd';

    /**
     * The index of the wallet to import.
     */
    index: number;
  }

  export interface PrivateKeyInitInput {
    /**
     * The address of the wallet to import.
     */
    address: string;

    /**
     * The chain type of the wallet to import. Currently supports `ethereum` and
     * `solana`.
     */
    chain_type: 'ethereum' | 'solana';

    /**
     * The encryption type of the wallet to import. Currently only supports `HPKE`.
     */
    encryption_type: 'HPKE';

    entropy_type: 'private-key';
  }
}

export interface WalletRawSignParams {
  /**
   * Body param:
   */
  params: WalletRawSignParams.Params;

  /**
   * Header param: Request authorization signature. If multiple signatures are
   * required, they should be comma separated.
   */
  'privy-authorization-signature'?: string;

  /**
   * Header param: Idempotency keys ensure API requests are executed only once within
   * a 24-hour window.
   */
  'privy-idempotency-key'?: string;
}

export namespace WalletRawSignParams {
  export interface Params {
    /**
     * The hash to sign. Must start with `0x`.
     */
    hash?: string;
  }
}

export type WalletRpcParams =
  | WalletRpcParams.EthereumSignTransactionRpcInput
  | WalletRpcParams.EthereumSendTransactionRpcInput
  | WalletRpcParams.EthereumPersonalSignRpcInput
  | WalletRpcParams.EthereumSignTypedDataRpcInput
  | WalletRpcParams.EthereumSign7702AuthorizationRpcInput
  | WalletRpcParams.EthereumSecp256k1SignRpcInput
  | WalletRpcParams.SolanaSignTransactionRpcInput
  | WalletRpcParams.SolanaSignAndSendTransactionRpcInput
  | WalletRpcParams.SolanaSignMessageRpcInput;

export declare namespace WalletRpcParams {
  export interface EthereumSignTransactionRpcInput {
    /**
     * Body param:
     */
    method: 'eth_signTransaction';

    /**
     * Body param:
     */
    params: EthereumSignTransactionRpcInput.Params;

    /**
     * Body param:
     */
    address?: string;

    /**
     * Body param:
     */
    chain_type?: 'ethereum';

    /**
     * Header param: Request authorization signature. If multiple signatures are
     * required, they should be comma separated.
     */
    'privy-authorization-signature'?: string;

    /**
     * Header param: Idempotency keys ensure API requests are executed only once within
     * a 24-hour window.
     */
    'privy-idempotency-key'?: string;
  }

  export namespace EthereumSignTransactionRpcInput {
    export interface Params {
      transaction: Params.Transaction;
    }

    export namespace Params {
      export interface Transaction {
        chain_id?: string | number;

        data?: string;

        from?: string;

        gas_limit?: string | number;

        gas_price?: string | number;

        max_fee_per_gas?: string | number;

        max_priority_fee_per_gas?: string | number;

        nonce?: string | number;

        to?: string;

        type?: 0 | 1 | 2;

        value?: string | number;
      }
    }
  }

  export interface EthereumSendTransactionRpcInput {
    /**
     * Body param:
     */
    caip2: string;

    /**
     * Body param:
     */
    method: 'eth_sendTransaction';

    /**
     * Body param:
     */
    params: EthereumSendTransactionRpcInput.Params;

    /**
     * Body param:
     */
    address?: string;

    /**
     * Body param:
     */
    chain_type?: 'ethereum';

    /**
     * Body param:
     */
    sponsor?: boolean;

    /**
     * Header param: Request authorization signature. If multiple signatures are
     * required, they should be comma separated.
     */
    'privy-authorization-signature'?: string;

    /**
     * Header param: Idempotency keys ensure API requests are executed only once within
     * a 24-hour window.
     */
    'privy-idempotency-key'?: string;
  }

  export namespace EthereumSendTransactionRpcInput {
    export interface Params {
      transaction: Params.Transaction;
    }

    export namespace Params {
      export interface Transaction {
        chain_id?: string | number;

        data?: string;

        from?: string;

        gas_limit?: string | number;

        gas_price?: string | number;

        max_fee_per_gas?: string | number;

        max_priority_fee_per_gas?: string | number;

        nonce?: string | number;

        to?: string;

        type?: 0 | 1 | 2;

        value?: string | number;
      }
    }
  }

  export interface EthereumPersonalSignRpcInput {
    /**
     * Body param:
     */
    method: 'personal_sign';

    /**
     * Body param:
     */
    params: EthereumPersonalSignRpcInput.Params;

    /**
     * Body param:
     */
    address?: string;

    /**
     * Body param:
     */
    chain_type?: 'ethereum';

    /**
     * Header param: Request authorization signature. If multiple signatures are
     * required, they should be comma separated.
     */
    'privy-authorization-signature'?: string;

    /**
     * Header param: Idempotency keys ensure API requests are executed only once within
     * a 24-hour window.
     */
    'privy-idempotency-key'?: string;
  }

  export namespace EthereumPersonalSignRpcInput {
    export interface Params {
      encoding: 'utf-8' | 'hex';

      message: string;
    }
  }

  export interface EthereumSignTypedDataRpcInput {
    /**
     * Body param:
     */
    method: 'eth_signTypedData_v4';

    /**
     * Body param:
     */
    params: EthereumSignTypedDataRpcInput.Params;

    /**
     * Body param:
     */
    address?: string;

    /**
     * Body param:
     */
    chain_type?: 'ethereum';

    /**
     * Header param: Request authorization signature. If multiple signatures are
     * required, they should be comma separated.
     */
    'privy-authorization-signature'?: string;

    /**
     * Header param: Idempotency keys ensure API requests are executed only once within
     * a 24-hour window.
     */
    'privy-idempotency-key'?: string;
  }

  export namespace EthereumSignTypedDataRpcInput {
    export interface Params {
      typed_data: Params.TypedData;
    }

    export namespace Params {
      export interface TypedData {
        domain: { [key: string]: unknown };

        message: { [key: string]: unknown };

        primary_type: string;

        types: { [key: string]: Array<TypedData.Type> };
      }

      export namespace TypedData {
        export interface Type {
          name: string;

          type: string;
        }
      }
    }
  }

  export interface EthereumSign7702AuthorizationRpcInput {
    /**
     * Body param:
     */
    method: 'eth_sign7702Authorization';

    /**
     * Body param:
     */
    params: EthereumSign7702AuthorizationRpcInput.Params;

    /**
     * Body param:
     */
    address?: string;

    /**
     * Body param:
     */
    chain_type?: 'ethereum';

    /**
     * Header param: Request authorization signature. If multiple signatures are
     * required, they should be comma separated.
     */
    'privy-authorization-signature'?: string;

    /**
     * Header param: Idempotency keys ensure API requests are executed only once within
     * a 24-hour window.
     */
    'privy-idempotency-key'?: string;
  }

  export namespace EthereumSign7702AuthorizationRpcInput {
    export interface Params {
      chain_id: string | number;

      contract: string;

      nonce?: string | number;
    }
  }

  export interface EthereumSecp256k1SignRpcInput {
    /**
     * Body param:
     */
    method: 'secp256k1_sign';

    /**
     * Body param:
     */
    params: EthereumSecp256k1SignRpcInput.Params;

    /**
     * Body param:
     */
    address?: string;

    /**
     * Body param:
     */
    chain_type?: 'ethereum';

    /**
     * Header param: Request authorization signature. If multiple signatures are
     * required, they should be comma separated.
     */
    'privy-authorization-signature'?: string;

    /**
     * Header param: Idempotency keys ensure API requests are executed only once within
     * a 24-hour window.
     */
    'privy-idempotency-key'?: string;
  }

  export namespace EthereumSecp256k1SignRpcInput {
    export interface Params {
      hash: string;
    }
  }

  export interface SolanaSignTransactionRpcInput {
    /**
     * Body param:
     */
    method: 'signTransaction';

    /**
     * Body param:
     */
    params: SolanaSignTransactionRpcInput.Params;

    /**
     * Body param:
     */
    address?: string;

    /**
     * Body param:
     */
    chain_type?: 'solana';

    /**
     * Header param: Request authorization signature. If multiple signatures are
     * required, they should be comma separated.
     */
    'privy-authorization-signature'?: string;

    /**
     * Header param: Idempotency keys ensure API requests are executed only once within
     * a 24-hour window.
     */
    'privy-idempotency-key'?: string;
  }

  export namespace SolanaSignTransactionRpcInput {
    export interface Params {
      encoding: 'base64';

      transaction: string;
    }
  }

  export interface SolanaSignAndSendTransactionRpcInput {
    /**
     * Body param:
     */
    caip2: string;

    /**
     * Body param:
     */
    method: 'signAndSendTransaction';

    /**
     * Body param:
     */
    params: SolanaSignAndSendTransactionRpcInput.Params;

    /**
     * Body param:
     */
    address?: string;

    /**
     * Body param:
     */
    chain_type?: 'solana';

    /**
     * Body param:
     */
    sponsor?: boolean;

    /**
     * Header param: Request authorization signature. If multiple signatures are
     * required, they should be comma separated.
     */
    'privy-authorization-signature'?: string;

    /**
     * Header param: Idempotency keys ensure API requests are executed only once within
     * a 24-hour window.
     */
    'privy-idempotency-key'?: string;
  }

  export namespace SolanaSignAndSendTransactionRpcInput {
    export interface Params {
      encoding: 'base64';

      transaction: string;
    }
  }

  export interface SolanaSignMessageRpcInput {
    /**
     * Body param:
     */
    method: 'signMessage';

    /**
     * Body param:
     */
    params: SolanaSignMessageRpcInput.Params;

    /**
     * Body param:
     */
    address?: string;

    /**
     * Body param:
     */
    chain_type?: 'solana';

    /**
     * Header param: Request authorization signature. If multiple signatures are
     * required, they should be comma separated.
     */
    'privy-authorization-signature'?: string;

    /**
     * Header param: Idempotency keys ensure API requests are executed only once within
     * a 24-hour window.
     */
    'privy-idempotency-key'?: string;
  }

  export namespace SolanaSignMessageRpcInput {
    export interface Params {
      encoding: 'base64';

      message: string;
    }
  }
}

export interface WalletSubmitImportParams {
  wallet: WalletSubmitImportParams.HDSubmitInput | WalletSubmitImportParams.PrivateKeySubmitInput;

  additional_signers?: Array<WalletSubmitImportParams.AdditionalSigner>;

  owner?: WalletSubmitImportParams.UserID | WalletSubmitImportParams.PublicKey | null;

  owner_id?: string | null;

  policy_ids?: Array<string>;
}

export namespace WalletSubmitImportParams {
  export interface HDSubmitInput {
    /**
     * The address of the wallet to import.
     */
    address: string;

    /**
     * The chain type of the wallet to import. Currently supports `ethereum` and
     * `solana`.
     */
    chain_type: 'ethereum' | 'solana';

    /**
     * The encrypted entropy of the wallet to import.
     */
    ciphertext: string;

    /**
     * The base64-encoded encapsulated key that was generated during encryption, for
     * use during decryption inside the TEE.
     */
    encapsulated_key: string;

    /**
     * The encryption type of the wallet to import. Currently only supports `HPKE`.
     */
    encryption_type: 'HPKE';

    /**
     * The entropy type of the wallet to import.
     */
    entropy_type: 'hd';

    /**
     * The index of the wallet to import.
     */
    index: number;
  }

  export interface PrivateKeySubmitInput {
    /**
     * The address of the wallet to import.
     */
    address: string;

    /**
     * The chain type of the wallet to import. Currently supports `ethereum` and
     * `solana`.
     */
    chain_type: 'ethereum' | 'solana';

    /**
     * The encrypted entropy of the wallet to import.
     */
    ciphertext: string;

    /**
     * The base64-encoded encapsulated key that was generated during encryption, for
     * use during decryption inside the TEE.
     */
    encapsulated_key: string;

    /**
     * The encryption type of the wallet to import. Currently only supports `HPKE`.
     */
    encryption_type: 'HPKE';

    entropy_type: 'private-key';
  }

  export interface AdditionalSigner {
    signer_id: string;

    override_policy_ids?: Array<string>;
  }

  export interface UserID {
    user_id: string;
  }

  export interface PublicKey {
    public_key: string;
  }
}

export interface WalletUpdateParams {
  /**
   * Body param: Additional signers for the wallet.
   */
  additional_signers?: Array<WalletUpdateParams.AdditionalSigner>;

  /**
   * Body param: The owner of the resource. If you provide this, do not specify an
   * owner_id as it will be generated automatically. When updating a wallet, you can
   * set the owner to null to remove the owner.
   */
  owner?: WalletUpdateParams.PublicKeyOwner | WalletUpdateParams.UserOwner | null;

  /**
   * Body param: The key quorum ID to set as the owner of the resource. If you
   * provide this, do not specify an owner.
   */
  owner_id?: string | null;

  /**
   * Body param: New policy IDs to enforce on the wallet. Currently, only one policy
   * is supported per wallet.
   */
  policy_ids?: Array<string>;

  /**
   * Header param: Request authorization signature. If multiple signatures are
   * required, they should be comma separated.
   */
  'privy-authorization-signature'?: string;
}

export namespace WalletUpdateParams {
  export interface AdditionalSigner {
    signer_id: string;

    /**
     * The array of policy IDs that will be applied to wallet requests. If specified,
     * this will override the base policy IDs set on the wallet.
     */
    override_policy_ids?: Array<string>;
  }

  /**
   * The P-256 public key of the owner of the resource. If you provide this, do not
   * specify an owner_id as it will be generated automatically.
   */
  export interface PublicKeyOwner {
    public_key: string;
  }

  /**
   * The user ID of the owner of the resource. The user must already exist, and this
   * value must start with "did:privy:". If you provide this, do not specify an
   * owner_id as it will be generated automatically.
   */
  export interface UserOwner {
    user_id: string;
  }
}

export interface WalletAuthenticateWithJwtParams {
  /**
   * The user's JWT, to be used to authenticate the user.
   */
  user_jwt: string;

  /**
   * The encryption type for the authentication response. Currently only supports
   * HPKE.
   */
  encryption_type?: 'HPKE';

  /**
   * The public key of your ECDH keypair, in base64-encoded, SPKI-format, whose
   * private key will be able to decrypt the session key.
   */
  recipient_public_key?: string;
}

export interface WalletCreateWalletsWithRecoveryParams {
  primary_signer: WalletCreateWalletsWithRecoveryParams.PrimarySigner;

  recovery_user: WalletCreateWalletsWithRecoveryParams.RecoveryUser;

  wallets: Array<WalletCreateWalletsWithRecoveryParams.Wallet>;
}

export namespace WalletCreateWalletsWithRecoveryParams {
  export interface PrimarySigner {
    /**
     * The JWT subject ID of the user.
     */
    subject_id: string;
  }

  export interface RecoveryUser {
    linked_accounts: Array<RecoveryUser.UnionMember0 | RecoveryUser.UnionMember1>;
  }

  export namespace RecoveryUser {
    export interface UnionMember0 {
      /**
       * The email address of the user.
       */
      address: string;

      type: 'email';
    }

    export interface UnionMember1 {
      /**
       * The JWT subject ID of the user.
       */
      custom_user_id: string;

      type: 'custom_auth';
    }
  }

  export interface Wallet {
    /**
     * The wallet chain types.
     */
    chain_type: WalletsAPI.WalletChainType;

    /**
     * List of policy IDs for policies that should be enforced on the wallet.
     * Currently, only one policy is supported per wallet.
     */
    policy_ids?: Array<string>;
  }
}

Wallets.Transactions = Transactions;
Wallets.Balance = Balance;

export declare namespace Wallets {
  export {
    type CurveSigningChainType as CurveSigningChainType,
    type FirstClassChainType as FirstClassChainType,
    type Wallet as Wallet,
    type WalletChainType as WalletChainType,
    type WalletRevokeResponse as WalletRevokeResponse,
    type WalletExportResponse as WalletExportResponse,
    type WalletInitImportResponse as WalletInitImportResponse,
    type WalletRawSignResponse as WalletRawSignResponse,
    type WalletRpcResponse as WalletRpcResponse,
    type WalletAuthenticateWithJwtResponse as WalletAuthenticateWithJwtResponse,
    type WalletCreateWalletsWithRecoveryResponse as WalletCreateWalletsWithRecoveryResponse,
    type WalletsCursor as WalletsCursor,
    type WalletCreateParams as WalletCreateParams,
    type WalletListParams as WalletListParams,
    type WalletExportParams as WalletExportParams,
    type WalletInitImportParams as WalletInitImportParams,
    type WalletRawSignParams as WalletRawSignParams,
    type WalletRpcParams as WalletRpcParams,
    type WalletSubmitImportParams as WalletSubmitImportParams,
    type WalletUpdateParams as WalletUpdateParams,
    type WalletAuthenticateWithJwtParams as WalletAuthenticateWithJwtParams,
    type WalletCreateWalletsWithRecoveryParams as WalletCreateWalletsWithRecoveryParams,
  };

  export {
    Transactions as Transactions,
    type TransactionGetResponse as TransactionGetResponse,
    type TransactionGetParams as TransactionGetParams,
  };

  export {
    Balance as Balance,
    type BalanceGetResponse as BalanceGetResponse,
    type BalanceGetParams as BalanceGetParams,
  };
}
